# 미션 - 블랙잭

순수한 Java를 활용한 블랙잭을 구현하기 위한 프로젝트입니다. 세부적인 규칙은 [블랙잭(카드게임)](https://namu.wiki/w/%EB%B8%94%EB%9E%99%EC%9E%AD(%EC%B9%B4%EB%93%9C%EA%B2%8C%EC%9E%84)) 과
[순수 Java로 이루어진 프로젝트](https://github.com/jojoldu/oop-java) 를 참고 하였습니다.

## 기능 요구사항
 * 딜러와 게이머 단 2명만 존재한다.
 * 카드는 조커를 제외한 52장이다.
 * 2 ~ 10은 숫자 그대로 점수를 반영하고, K/Q/J는 10점으로, A는 1로 계산한다. (기존 규칙은 A가 1, 11 모두 가능하다. 간단한 규칙을 위해 스펙아웃을 진행한다.)
 * 딜러와 게이머는 순차적으로 카드를 하나씩 뽑아 각자 2개의 카드를 소지한다.
 * 게이머는 얼마든지 카드를 추가로 뽑을 수 있다.
 * 딜러는 2 카드의 합계 점수가 16점 이하이면 반드시 1장을 추가로 뽑고, 17점 이상이면 추가할 수 없다.
 * 양쪽 다 추가 뽑기 없이 카드를 오픈하면 딜러와 게이머 중 소유한 카드의 합이 21에 가장 가까운 쪽이 승리한다.
 * 단 21을 초과하면 초과한 쪽이 진다.

## 설계 원칙

> 설계 원칙은 [목적의식 있는 연습을 통한 효과적인 학습](https://brunch.co.kr/@javajigi/8) 해당 글에 담긴 피드백을 통해 반영 및 재구성 하였습니다.

### 이름을 통해 의도를 드러내라
협업을 위해 가장 중요한 활동 중 하나는 좋은 이름 짓기이다. 변수 이름, 메서드 이름, 클래스 이름을 짓는데 시간을 투자한다. 
이름을 통해 변수의 역할, 함수의 역할, 클래스의 역할에 대한 의도를 드러내기 위해 노력한다. 

또한 축약하지 않는다. 의도를 드러낼 수 있다면 이름이 길어져도 괜찮다.

### 공백도 코딩 컨벤션의 일부분이다
공백 라인을 의미 있게 사용하는 것이 좋아 보이며, 문맥을 분리하는 부분에 사용하는 것이 좋다.

### 반복하지 마라
중복은 소프트웨어에서 모든 악의 근원이다.

### 의미 없는 주석을 달지 않는다
변수 이름, 메서드 이름을 통해 의도를 드러낸다. 

### 커밋 메시지를 의미 있게 작성하라
커밋 메시지에 해당 커밋에서 작업한 내용에 대한 이해가 가능하도록 작성한다.

### 기능 목록을 업데이트하라
`README.md`파일에 작성하는 기능 목록은 기능 구현을 하면서 변경될 수 있다. 
시작할 때 모든 기능 목록을 완벽하게 정리해야 한다는 부담감을 가지기 보다 기능을 구현하면서 문서를 계속 업데이트 한다.
죽은 문서가 아니라 `살아 있는 문서`를 만들기 위해 노력한다.

구현해야 할 기능 목록을 정리하는데 집중한다. `정상적인 경우도 중요하지만, 예외적인 상황도 기능 목록`에 정리한다.

### 매직 넘버, 매직 리터럴을 사용하지 마라
의미를 나타낼 수 있는 상수 (static final)로 치환하여 코드의 가독성을 높인다.

### 구현 순서도 코딩 컨벤션이다
 * [형식 맞추기](https://hyeonic.github.io/%EA%B8%B0%ED%83%80/clean-code/match-the-format.html)

### 메서드 라인은 15줄, depth는 2까지 허용한다
만약 whil문 안에 if이 있으면 depth는 2가 된다. depth를 줄이는 방법은 메서드를 분리하면 된다.

### 3항 연산자를 쓰지 않는다

### else 예약어를 쓰지 않는다
if 조건절에서 값을 return하는 방식으로 구현하면 else를 사용하지 않아도 된다.
 * [다형성을 사용해 if/else를 제거하는 리팩토링을 하라.](https://slipp.net/questions/566)

### Java Collection을 사용하라
Java Collection 자료구조를 사용하면 데이터를 조작할 때 다양한 api를 사용할 수 있다.

### 객체에게 메시지를 보내라
상태를 가지는 객체에게 데이터를 꺼내려 하지말고 객체에게 메시지를 보낸다.

### 인스턴스 변수의 수를 줄이기 위해 노력한다
인스턴스 변수의 수가 많은 것은 객체의 복잡도를 높이고, 버그 발생 가능성을 높일 수 있다. 불필요한 인스턴스 변수를 줄여 최소화한다.

### 비즈니스 로직과 UI 로직을 분리해라
비즈니스 로직과 UI 로직을 한 클래스가 담당하지 않도록 한다. 
현재 객체의 상태를 보기 위한 로그 메시지 성격이 강하다면 `toString()`을 통해 구현한다.
View에서 사용할 데이터라면 `getter 메서드`를 통해 데이터를 전달한다.

### 원시 타입과 문자열을 포장하라
 * [모든 원시값과 문자열을 포장하라](https://hyeonic.github.io/%EA%B8%B0%ED%83%80/woowacourse/precourse-2.html#_8-%E1%84%86%E1%85%A9%E1%84%83%E1%85%B3%E1%86%AB-%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%89%E1%85%B5%E1%84%80%E1%85%A1%E1%86%B9%E1%84%80%E1%85%AA-%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%A7%E1%86%AF%E1%84%8B%E1%85%B3%E1%86%AF-%E1%84%91%E1%85%A9%E1%84%8C%E1%85%A1%E1%86%BC%E1%84%92%E1%85%A1%E1%84%85%E1%85%A1)
 * [원시 타입을 포장해야 하는 이유](https://tecoble.techcourse.co.kr/post/2020-05-29-wrap-primitive-type/)

### 클래스 우선이 아닌, 객체의 속성과 행위가 우선이다
클래스는 객체를 추상화하는 도구일 뿐이다.

### 데이터가 아닌 메시지를 중심으로 객체를 설계해라
객체는 혼자 있을 수 없다. 다른 객체와의 `협력` 안에서만 존재할 수 있다.
메시지를 중심으로, 해당 메시지가 어떤 객체를 필요로 하는지 생각한다.

### 하나하나 지시하지 말고 요청해라
예를 들면, 판사가 증인에게 1) 목격 했던 장면을 떠올리고, 2) 떠오르는 시간을 순서대로 구성하고, 3) 말로 간결하게 표현해라 라고 요청하지 않는다. 그냥 "증언하라"라고 요청한다.
마찬가지로 객체의 설계 단계에서도 책임이 있는 객체에 요청만 하도록 설계한다.

### 하나의 메서드는 하나의 일만 해야 한다
처음부터 완벽한 설계는 없다. 설계를 코드로 구현해가는 과정에서 수정이 필요하다면 설계를 수정한다.

## References
 * [목적의식 있는 연습을 통한 효과적인 학습](https://brunch.co.kr/@javajigi/8)
 * [순수 Java로 이루어진 프로젝트](https://github.com/jojoldu/oop-java)
 * [java-vendingmachine-precourse](https://github.com/woowacourse/java-vendingmachine-precourse)